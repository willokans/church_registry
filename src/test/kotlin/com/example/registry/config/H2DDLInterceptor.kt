package com.example.registry.config

import org.hibernate.resource.jdbc.spi.StatementInspector
import org.springframework.boot.autoconfigure.orm.jpa.HibernatePropertiesCustomizer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.test.context.ActiveProfiles
import javax.sql.DataSource
import java.io.PrintWriter
import java.sql.*
import java.util.Properties
import java.util.logging.Logger

/**
 * H2-compatible StatementInspector that modifies SQL to replace TIMESTAMP(0) with TIMESTAMP.
 * This is needed because H2 doesn't support TIMESTAMP(0) syntax.
 * 
 * Note: StatementInspector intercepts SQL statements, but DDL during schema creation
 * is handled by a custom DataSource proxy that intercepts at the JDBC level.
 */
class H2StatementInspector : StatementInspector {
    override fun inspect(sql: String?): String? {
        return sql?.replace("\"TIMESTAMP(0)\"", "\"TIMESTAMP\"")
                  ?.replace("TIMESTAMP(0)", "TIMESTAMP")
    }
}

/**
 * Custom DataSource proxy that intercepts SQL at the JDBC level and modifies DDL statements.
 * This catches DDL statements during schema creation and replaces TIMESTAMP(0) with TIMESTAMP.
 */
class H2DataSourceProxy(private val delegate: DataSource) : DataSource {
    override fun getConnection(): Connection {
        return H2ConnectionProxy(delegate.connection)
    }
    
    override fun getConnection(username: String?, password: String?): Connection {
        return H2ConnectionProxy(delegate.getConnection(username, password))
    }
    
    override fun getLogWriter(): PrintWriter = delegate.logWriter
    override fun setLogWriter(out: PrintWriter?) { delegate.logWriter = out }
    override fun setLoginTimeout(seconds: Int) { delegate.loginTimeout = seconds }
    override fun getLoginTimeout(): Int = delegate.loginTimeout
    override fun getParentLogger(): Logger = delegate.parentLogger
    override fun <T : Any?> unwrap(iface: Class<T>?): T = delegate.unwrap(iface)
    override fun isWrapperFor(iface: Class<*>?): Boolean = delegate.isWrapperFor(iface)
}

/**
 * Connection proxy that intercepts PreparedStatement creation and modifies SQL.
 */
class H2ConnectionProxy(private val delegate: Connection) : Connection {
    override fun prepareStatement(sql: String?): PreparedStatement {
        val modifiedSql = sql?.replace("\"TIMESTAMP(0)\"", "\"TIMESTAMP\"")
                            ?.replace("TIMESTAMP(0)", "TIMESTAMP")
        return delegate.prepareStatement(modifiedSql)
    }
    
    override fun prepareStatement(sql: String?, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement {
        val modifiedSql = sql?.replace("\"TIMESTAMP(0)\"", "\"TIMESTAMP\"")
                            ?.replace("TIMESTAMP(0)", "TIMESTAMP")
        return delegate.prepareStatement(modifiedSql, resultSetType, resultSetConcurrency)
    }
    
    override fun prepareStatement(sql: String?, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement {
        val modifiedSql = sql?.replace("\"TIMESTAMP(0)\"", "\"TIMESTAMP\"")
                            ?.replace("TIMESTAMP(0)", "TIMESTAMP")
        return delegate.prepareStatement(modifiedSql, resultSetType, resultSetConcurrency, resultSetHoldability)
    }
    
    override fun prepareStatement(sql: String?, autoGeneratedKeys: Int): PreparedStatement {
        val modifiedSql = sql?.replace("\"TIMESTAMP(0)\"", "\"TIMESTAMP\"")
                            ?.replace("TIMESTAMP(0)", "TIMESTAMP")
        return delegate.prepareStatement(modifiedSql, autoGeneratedKeys)
    }
    
    override fun prepareStatement(sql: String?, columnIndexes: IntArray?): PreparedStatement {
        val modifiedSql = sql?.replace("\"TIMESTAMP(0)\"", "\"TIMESTAMP\"")
                            ?.replace("TIMESTAMP(0)", "TIMESTAMP")
        return delegate.prepareStatement(modifiedSql, columnIndexes)
    }
    
    override fun prepareStatement(sql: String?, columnNames: Array<out String>?): PreparedStatement {
        val modifiedSql = sql?.replace("\"TIMESTAMP(0)\"", "\"TIMESTAMP\"")
                            ?.replace("TIMESTAMP(0)", "TIMESTAMP")
        return delegate.prepareStatement(modifiedSql, columnNames)
    }
    
    override fun createStatement(): Statement = delegate.createStatement()
    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement = 
        delegate.createStatement(resultSetType, resultSetConcurrency)
    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement = 
        delegate.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability)
    override fun prepareCall(sql: String?): CallableStatement = delegate.prepareCall(sql)
    override fun prepareCall(sql: String?, resultSetType: Int, resultSetConcurrency: Int): CallableStatement = 
        delegate.prepareCall(sql, resultSetType, resultSetConcurrency)
    override fun prepareCall(sql: String?, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): CallableStatement = 
        delegate.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability)
    override fun nativeSQL(sql: String?): String = delegate.nativeSQL(sql)
    override fun setAutoCommit(autoCommit: Boolean) { delegate.autoCommit = autoCommit }
    override fun getAutoCommit(): Boolean = delegate.autoCommit
    override fun commit() { delegate.commit() }
    override fun rollback() { delegate.rollback() }
    override fun close() { delegate.close() }
    override fun isClosed(): Boolean = delegate.isClosed
    override fun getMetaData(): DatabaseMetaData = delegate.metaData
    override fun setReadOnly(readOnly: Boolean) { delegate.isReadOnly = readOnly }
    override fun isReadOnly(): Boolean = delegate.isReadOnly
    override fun setCatalog(catalog: String?) { delegate.catalog = catalog }
    override fun getCatalog(): String? = delegate.catalog
    override fun setTransactionIsolation(level: Int) { delegate.transactionIsolation = level }
    override fun getTransactionIsolation(): Int = delegate.transactionIsolation
    override fun getWarnings(): SQLWarning? = delegate.warnings
    override fun clearWarnings() { delegate.clearWarnings() }
    override fun getTypeMap(): MutableMap<String, Class<*>> = delegate.typeMap
    override fun setTypeMap(map: MutableMap<String, Class<*>>?) { delegate.typeMap = map }
    override fun setHoldability(holdability: Int) { delegate.holdability = holdability }
    override fun getHoldability(): Int = delegate.holdability
    override fun setSavepoint(): Savepoint = delegate.setSavepoint()
    override fun setSavepoint(name: String?): Savepoint = delegate.setSavepoint(name)
    override fun rollback(savepoint: Savepoint?) { delegate.rollback(savepoint) }
    override fun releaseSavepoint(savepoint: Savepoint?) { delegate.releaseSavepoint(savepoint) }
    override fun createClob(): Clob = delegate.createClob()
    override fun createBlob(): Blob = delegate.createBlob()
    override fun createNClob(): NClob = delegate.createNClob()
    override fun createSQLXML(): SQLXML = delegate.createSQLXML()
    override fun isValid(timeout: Int): Boolean = delegate.isValid(timeout)
    override fun setClientInfo(name: String?, value: String?) { delegate.setClientInfo(name, value) }
    override fun setClientInfo(properties: Properties?) { delegate.setClientInfo(properties) }
    override fun getClientInfo(name: String?): String? = delegate.getClientInfo(name)
    override fun getClientInfo(): Properties = delegate.clientInfo
    override fun createArrayOf(typeName: String?, elements: Array<Any>?): java.sql.Array = delegate.createArrayOf(typeName, elements)
    override fun createStruct(typeName: String?, attributes: Array<Any>?): Struct = delegate.createStruct(typeName, attributes)
    override fun setSchema(schema: String?) { delegate.schema = schema }
    override fun getSchema(): String? = delegate.schema
    override fun abort(executor: java.util.concurrent.Executor?) { delegate.abort(executor) }
    override fun setNetworkTimeout(executor: java.util.concurrent.Executor?, milliseconds: Int) { delegate.setNetworkTimeout(executor, milliseconds) }
    override fun getNetworkTimeout(): Int = delegate.networkTimeout
    override fun <T : Any?> unwrap(iface: Class<T>?): T = delegate.unwrap(iface)
    override fun isWrapperFor(iface: Class<*>?): Boolean = delegate.isWrapperFor(iface)
}

@Configuration
@ActiveProfiles("test")
class H2TestConfig {
    @Bean
    fun hibernatePropertiesCustomizer(): HibernatePropertiesCustomizer {
        return HibernatePropertiesCustomizer { properties ->
            // Use StatementInspector for regular SQL statements
            properties["hibernate.session_factory.statement_inspector"] = H2StatementInspector::class.java.name
        }
    }
}

